1. rabbitmq的高可用
   
   RabbitMQ 是比较有代表性的,因为是基于主从做高可用性的
   
   rabbitmq 有三种模式： 单机模式， 普通集群模式， 镜像集群模式
   

- 单机模式
  
    demo用,生产没人用单机
  

- 普通集群模式

    多台机器多个rabbitmq实例,创建一个queue只会放到一个mq实例里,但是每个实例都会同步queue的元数据,在进行消息消费的时候,如果连接到a实例,queue的数据在b,那么a实例会从b实例拉取数据
    
    这种模式麻烦不友好,假如存放queue的实例宕机,别的实例就没办法从该实例拉取数据,如果开启持久化,消息虽然不会丢失,但是必须等到机器恢复才可以进行消费,没法做到高可用


- 镜像集群模式 
  
    rabbitmq 的高可用模式，跟普通集群模式不一样的是，创建的 queue，无论元数据还是queue里的消息都会存在于多个实例上， 然后每次你写消息到queue的时候，
    都会自动把消息到多个实例的queue里的消息进行消息同步
  
    好处:任何一个机器宕机都不影响消息的发送和消费,实现可高可用

    坏处:开销大,所有的消息都进行同步会有很大的网络带宽压力.没有扩展性,新增机器也包含所有的数据,并没有办法扩展queue

2. kafka的高可用
   
    kafka基础架构:多个broker组成,每一个broker是一个节点,创建一个topic会划分为多个partition,每个partition存在于不同的broker上,每个partition只有一部分数据
    这就是天然的分布式消息队列，就是说一个topic的数据，是分散放在多个机器上的，每个机器就放一部分数据。
   
    实际上rabbitmq并不是分布式消息队列,只不过提供了集群、HA的机制,无论怎么使用,一个queue的数据都会完整的存放到一个节点里

    kafka有replica副本机制,每个partition都有多个副本,副本会分布到不同的broker上,然后所有的replica会选举出一个leader,生产消费都与leader打交道,其他的replica都是follower,写的时候
    leader会负责将数据同步到所有的follower,读的时候也是直接读取leader的数据
   
    为什么只能读取leader的数据?随意读写follower会有数据一致性问题

    
    
