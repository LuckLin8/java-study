## redis是不是单线程？
我们通常说，Redis 是单线程，主要是指 Redis 的网络 IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。

但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的

## redis为什么采用单线程？

要更好地理解 Redis 为什么用单线程，我们就要先了解多线程的开销。

### 多线程的开销

一般来说： 使用多线程可以增加系统的吞吐率，或者可以增加系统的扩展性。

的确，对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。

但是，在采用多线程编程的过程中，如果没有良好的系统设计，刚开始增加线程数系统吞吐量会增加，但是进一步增加线程系统的吞吐量会增长迟缓甚至下降

![吞吐量对比](https://youdaoyun1.oss-cn-shenzhen.aliyuncs.com/ES/%E5%90%9E%E5%90%90%E9%87%8F%E5%AF%B9%E6%AF%94.jpg)

**多线程存在的瓶颈**

系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。

    拿 Redis 来说，Redis 有 List 的数据类型，并提供出队（LPOP）和入队（LPUSH）操作。假设 Redis 采用多线程设计，现在有两个线程 A 和B，线程 A 对一个 List 做 LPUSH 操作，并对队列长度加 1。
    同时，线程 B 对该 List 执行LPOP 操作，并对队列长度减 1。为了保证队列长度的正确性，Redis 需要让线程 A 和 B的 LPUSH 和 LPOP 串行执行，这样一来，Redis 可以无误地记录它们对 List 长度的修改。
    否则，我们可能就会得到错误的长度结果。这就是多线程编程模式面临的共享资源的并发访问控制问题。
    
## 单线程的redis为什么这么快?
- 大部分操作都是在内存上完成
- 高效的数据结构，哈希表，跳表
- redis采用非阻塞io模型，多路io复用

像理解多路io复用，必须弄明白网络操作的基本io模型和潜在的阻塞点

### 基本IO模型与阻塞点
以get请求为例，处理一个 Get 请求，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析
客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。

![基本io模型](https://youdaoyun1.oss-cn-shenzhen.aliyuncs.com/ES/redis%E5%9F%BA%E6%9C%ACio%E6%A8%A1%E5%9E%8B.jpg)

观察基本io模型的处理逻辑可以发现存在两个潜在的阻塞点，分别为accept()和recv()
- 当redis监听到一个客户端有连接请求但是一直未建立连接时，会阻塞在accept()导致其它客户端无法建立连接
- 当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()

这就导致整个线程阻塞，无法处理其它客户端的请求，效率很低

### 非阻塞模式思想
非阻塞模式说白了就是在，等待建立连接和等待接收数据的时候可以处理其它操作

- 当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了
- Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis

这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis无法处理实际到达的连接请求或数据。

到此，Linux 中的 IO 多路复用机制就要登场了。

### 基于多路复用的高性能IO模型
Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的**select/epoll 机制**简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同
时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个IO 流的效果。

![多路io复用](https://youdaoyun1.oss-cn-shenzhen.aliyuncs.com/ES/%E5%A4%9A%E8%B7%AFio%E5%A4%8D%E7%94%A8.jpg)

为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数

其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件

这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，
Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对**事件队列**进行处理，所以能及时响应客户端请求，提升Redis 的响应性能