## Redis高可用
一般来说Redis具备高可用性包括两点：1. 数据尽量少丢失  2. 服务尽量少中断

AOF和RDB日志保证了前者，对于服务尽量少中断，redis采用**增加副本冗余量**，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用

多实例保存同一份数据需要考虑一个问题： 这么多副本，它们之间的数据如何保持一致

## 主从库的数据拷贝

Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式

- 读操作：主库、从库都可以接收；
- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

### 主从库间如何进行第一次同步？

当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。

```java
replicaof 172.16.19.3 6379
```

![redis第一次同步](https://blog-images12.oss-cn-beijing.aliyuncs.com/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.jpg)

1. 第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了
    
    具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。
    
    runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。
    
    offset，此时设为 -1，表示第一次复制。

2. **主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载**。这个过程依赖于内存快照生成的 **RDB** 文件

    具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。
    这是因为从库在通过 replicaof命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。
    
    主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。
    为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录RDB 文件生成后收到的所有写操作
    
3. 主库会把第二阶段执行过程中新收到的写命令，再发送给从库。

    具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了
    
### 主从级联模式分担全量复制时的主库压力

通过分析主从库间第一次数据同步的过程，一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件

如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致
主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力

**主库同步数据压力过大怎么办？** -- “主 - 从 - 从”模式

主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，可以通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。

### 主从库间的网络断了怎么办？

在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大

从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步

    当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。
    
    repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置
    
![redis环形复制](https://blog-images12.oss-cn-beijing.aliyuncs.com/redis%E7%8E%AF%E5%BD%A2%E5%A4%8D%E5%88%B6.jpg)

主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset之间的差距
此时，主库只用把 master_repl_offset 和 slave_repl_offset之间的命令操作同步给从库就行

因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，

此时，就会覆盖掉之前写入的操作。**如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致**

一般而言，我们可以调整 repl_backlog_size 这个参数,repl_backlog_size = 缓冲空间大小 * 2   (缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小)

### 为什么主从库间的复制不使用 AOF 呢？

- 对于从库来说，RDB文件可以更迅速的数据同步 
- AOF文件过大，网络传输比较耗时

### 小结

全量复制虽然耗时，但是对于从库来说，如果是第一次同步，全量复制是无法避免的，所以，我给你一个小建议：一个 Redis 实例的数据库不要太大，一个实例大小在几 GB 级别比较合适，这样可以减少 RDB 文件生成、传输和重新加载的开销

为了避免多个从库同时和主库进行全量复制，给主库过大的同步压力，我们也可以采用“主 - 从 - 从”这一级联模式，来缓解主库的压力。