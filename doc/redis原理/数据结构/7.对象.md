## 对象
Redis 并没有直接使用链表、跳表等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含String、list、hash、set和zset对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。

通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。

除此之外， Redis 的对象系统还实现了基于**引用计数技术**的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。

最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。

## 实现
Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：
```
typedef struct redisObject {

    // 类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    // 指向底层实现数据结构的指针
    void *ptr;

    // ...

} robj;
```

type记录的为对象的类型：

| 类型常量 | 对象的名称 |
| ----    | ---- | 
| REDIS_STRING|	字符串对象|
| REDIS_LIST|	列表对象|
| REDIS_HASH|	哈希对象|
| REDIS_SET	|集合对象|
| REDIS_ZSET|	有序集合对象|

对象底层锁采用的数据结构：

|对象所使用的底层数据结构|命令输出|
|----|----|
|整数|"int"|
|embstr|"embstr"|
|简单动态字符串|"raw"|
|字典|"hashtable"|
|双端链表|"linkedlist"|
|压缩列表|"ziplist"|
|整数集合|"intset"|
|跳跃表和字典|"skiplist"|
    
Redis 缓存保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、list对象、哈希对象、set对象、zset对象的其中一种

### 字符串对象
字符串对象的编码可以是 int 、 raw 或者 embstr

- 如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。

- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。
    
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。

    > embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 
    >
    > 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构

|值|编码|
|----|----|
|可以用 long 类型保存的整数。|int|
|可以用 long double 类型保存的浮点数。|embstr 或者 raw|
|字符串值，或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用long double 类型表示的浮点数。|embstr 或者 raw|

### list
列表对象的编码可以是 ziplist 或者 linkedlist

当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：

- 列表对象保存的所有字符串元素的长度都小于 64 字节；
- 列表对象保存的元素数量小于 512 个；

### Hash对象
哈希对象的编码可以是 ziplist 或者 hashtable

1. ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：

    - 保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；
    - 先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。
    
2. hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：

    - 字典的每个键都是一个字符串对象， 对象中保存了键值对的键；
    - 字典的每个值都是一个字符串对象， 对象中保存了键值对的值。
    
### Set
Set对象的编码可以是 intset 或者 hashtable

### ZSet
有序集合的编码可以是 ziplist 或者 skiplist


## 重点
- Redis 数据库中的每个键值对的键和值都是一个对象。
- Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。
- 服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。
- Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。
- Redis 会共享值为 0 到 9999 的字符串对象。
- 对象会记录自己的最后一次被访问的时间（lru）， 这个时间可以用于计算对象的空转时间
    
