##  如何使用Redis实现分布式锁？

**核心：**

```SET key value [EX seconds | PX milliseconds] [NX]```

setnx，不存在就创建返回1，存在不创建不更新返回0

单个命令保证原子性

### 怎么保证业务出现异常导致锁一直无法释放？
    
    给锁变量添加过期时间，即使持有锁的客户端发生了异常，无法主动地释放锁，Redis 也会根据锁变量的过期时间，在锁变量过期后，把它删除

### 怎么保证不会存在别的线程，误删除key，导致多个线程同时拿到锁？

    key的value值写入线程的的唯一值，这里的唯一值就可以用来标识当前操作的客户端，在释放锁操作时，客户端需要判断，当前锁变量的值是否和自己的唯一
    标识相等，只有在相等的情况下，才能释放锁。这样一来，就不会出现误释放锁的问题了
    
    同样为了保证判断当前持有锁的线程是否为释放锁的线程的原子性，需要采用lua脚本进行判断
```java
//释放锁 比较unique_value是否相等，避免误释放
if redis.call("get",KEYS[1]) == ARGV[1] then 
    return redis.call("del",KEYS[1]) 
else
    return 0 
end
```

### 基于多个 Redis 节点实现高可靠的分布式锁--Redlock

使用 SET 命令和 Lua 脚本在 Redis 单节点上实现分布式锁。但是，我们现在只用了一个 Redis 实例来保存锁变量，如果这个 Redis 实例发生故障宕机了，
那么锁变量就没有了。此时，客户端也无法进行锁操作了，这就会影响到业务的正常执行。所以，我们在实现分布式锁时，还需要保证锁的可靠性。那怎么提高呢？
这就要提到基于多个 Redis 节点实现分布式锁的方式了。

Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布
式锁了，否则加锁失败。这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失

1. 客户端获取当前时间
2. 客户端按顺序依次向 N 个 Redis 实例执行加锁操作
    
    这里的加锁操作和在单实例上执行的加锁操作一样，使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。当然，如果某个 Redis 实例发生故障了，为了保证在这
    种情况下，Redlock 算法能够继续运行，我们需要给加锁操作设置一个超时时间
    
    如果客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时
    间，一般也就是设置为几十毫秒  
    
3. 一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时
    
    客户端只有在满足下面的这两个条件时，才能认为是加锁成功。
    1.客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁
    2.客户端获取锁的总耗时没有超过锁的有效时间
    
    在满足了这两个条件后，我们需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作
    了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况

### 扩展：redisson的WatchDog是如何看家护院的？

如果加锁后线程执行时间过长超过超时时间，redisson如何处理？

https://blog.csdn.net/ice24for/article/details/86177152