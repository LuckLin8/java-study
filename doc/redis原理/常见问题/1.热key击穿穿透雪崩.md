## 热key，怎么解决？
### 热key是什么？
热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。

接下来这个key的请求，就会直接怼到数据库上，导致服务不可用。

### 如何解决热key问题
1. 二级缓存利用ehcache，或者一个HashMap都可以。在发现热key以后，把热key加载到系统的JVM中（类似soul网关的二级缓存，把接口路径从库中同步到jvm缓存中，相当于预加载）

2. 提前把热key打散到不同的服务器，降低压力

## 缓存击穿
### 缓存击穿是什么？
缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。

### 如何解决？

加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。

使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用setnx加锁，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法
```java
    public String get(key) {
        String value = redis.get(key);
        if (value == null) { //代表缓存值过期
            //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
            if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
                value = db.get(key);
                redis.set(key, value, expire_secs);
                redis.del(key_mutex);
            } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
                sleep(50);
                get(key);  //重试
            }
        } else {
            return value;
        }
    }
```

## 缓存穿透
### 缓存穿透是什么？
缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。

### 如何解决？
1. 布隆过滤器，通过布隆过滤器去拦截，查询布隆过滤器返回0直接返回，不会在打到db，但是布隆过滤器会有误判问题，误判率和hash算法有关

2. 每次请求不存在的结果在redis中写入对应的key和null值设置过期时间（临时解决方案）

## 缓存雪崩
### 缓存雪崩是什么？

当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。

### 如何解决？

1. 针对不同key设置不同的过期时间，避免同时过期
2. 限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB
3. 二级缓存，同热key的方案。
4. 加锁排队，解决不了吞吐量问题


