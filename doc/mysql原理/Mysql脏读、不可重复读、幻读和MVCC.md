## 脏读、不可重复读、幻读

### 脏读

隔离级别：**读未提交**

A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据

### 不可重复读

隔离级别：**读未提交、读已提交**

事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间
。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读

### 幻读

隔离级别：**读未提交、读已提交、可重复读**

事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

### 不可重复读和幻读的区别

1. 不可重复读是读取了其他事务更改的数据，针对update操作

2. 幻读是读取了其他事务新增的数据，针对insert和delete操作

## ACID

1. 原子性：事务包含的所有数据库操作要么全部成功，要不全部失败回滚
2. 一致性：一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
3. 隔离性：一个事务未提交的业务结果是否对于其它事务可见。级别一般有：read_uncommit，read_commit，read_repeatable，Serializable 串行化访问。
4. 持久性：一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

## 隔离级别

| |脏读|不可重复读|幻读|
|----|----|----|----|
|Read uncommitted|y|y|y|
|Read committed|n|y|y|
|Repeatable read|n|n|y|
|Serializable|n|n|n|

##MVCC（多版本并发控制）
Multi-Version Concurrency Control

乐观锁为理论基础的MVCC（多版本并发控制），MVCC的实现没有固定的规范。每个数据库都会有不同的实现方式。

mysql中，默认的事务隔离级别是可重复读`（repeatable-read）`，为了解决不可重复读，innodb采用了MVCC（多版本并发控制）来解决这一问题。

MVCC是利用在每条数据后面加了隐藏的两列（创建版本号和删除版本号），每个事务在开始的时候都会有一个递增的版本号

- 而每一个事务在启动的时候，都有一个唯一的递增的版本号。

1. 在插入操作时 ： 记录的创建版本号就是事务版本号。

    比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。
    
    |id|name|create_version|delete_version|
    |----|----|----|----|
    |1|test|1||	　　		 
2. 在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。

    比如，针对上面那行记录，事务Id为2 要把name字段更新
    
    ```sql
    update table set name= 'new_value' where id=1;
    ```
    
    |id|name|create_version|delete_version|
    |----|----|----|----|
    |1|test|1|2|
    |1|new_value|2||

3. 删除操作的时候，就把事务版本号作为删除版本号。比如
    ```sql
    delete from table where id=1;
    ```
    |id|name|create_version|delete_version|
    |----|----|----|----|
    |1|new_value|2|3|

4. 查询操作：

    从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：
    
    1）InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，只么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
    
    2）行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。


> 这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是：
> 
> 通过版本号来减少锁的争用。

> 只有read-committed和 repeatable-read 两种事务隔离级别才能使用mvcc
>
> read-uncommited由于是读到未提交的，所以不存在版本的问题
>
> 而serializable 则会对所有读取的行加锁。 

 